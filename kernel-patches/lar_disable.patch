diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/iwl-drv.c b/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
--- a/drivers/net/wireless/intel/iwlwifi/iwl-drv.c	2023-08-10 16:45:44.826948061 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-drv.c	2023-08-10 17:12:56.313785041 -0500
@@ -1899,6 +1899,9 @@
 module_param_named(nvm_file, iwlwifi_mod_params.nvm_file, charp, 0444);
 MODULE_PARM_DESC(nvm_file, "NVM file name");
 
+module_param_named(lar_disable, iwlwifi_mod_params.lar_disable, bool, 0444);
+MODULE_PARM_DESC(lar_disable, "disable LAR functionality (default: N)");
+
 module_param_named(uapsd_disable, iwlwifi_mod_params.uapsd_disable, uint, 0644);
 MODULE_PARM_DESC(uapsd_disable,
 		 "disable U-APSD functionality bitmap 1: BSS 2: P2P Client (default: 3)");
diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/iwl-modparams.h b/drivers/net/wireless/intel/iwlwifi/iwl-modparams.h
--- a/drivers/net/wireless/intel/iwlwifi/iwl-modparams.h	2023-08-10 16:46:18.163337313 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-modparams.h	2023-08-10 17:12:46.573672404 -0500
@@ -78,6 +78,7 @@
 #endif
 	char *nvm_file;
 	u32 uapsd_disable;
+	bool lar_disable;
 	bool disable_11ac;
 	/**
 	 * @disable_11ax: disable HE capabilities, default = false
diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c	2023-08-10 16:46:56.955790220 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c	2023-08-10 17:12:35.817548029 -0500
@@ -1375,7 +1375,7 @@
 		   const __be16 *nvm_hw, const __le16 *nvm_sw,
 		   const __le16 *nvm_calib, const __le16 *regulatory,
 		   const __le16 *mac_override, const __le16 *phy_sku,
-		   u8 tx_chains, u8 rx_chains)
+		   u8 tx_chains, u8 rx_chains, bool lar_fw_supported)
 {
 	struct iwl_nvm_data *data;
 	bool lar_enabled;
@@ -1455,8 +1455,7 @@
 		return NULL;
 	}
 
-	if (lar_enabled &&
-	    fw_has_capa(&fw->ucode_capa, IWL_UCODE_TLV_CAPA_LAR_SUPPORT))
+	if (lar_fw_supported && lar_enabled)
 		sbands_flags |= IWL_NVM_SBANDS_FLAGS_LAR;
 
 	if (iwl_nvm_no_wide_in_5ghz(trans, cfg, nvm_hw))
@@ -1901,6 +1900,9 @@
 		.id = WIDE_ID(REGULATORY_AND_NVM_GROUP, NVM_GET_INFO)
 	};
 	int  ret;
+	bool lar_fw_supported = !iwlwifi_mod_params.lar_disable &&
+				fw_has_capa(&fw->ucode_capa,
+					    IWL_UCODE_TLV_CAPA_LAR_SUPPORT);
 	bool empty_otp;
 	u32 mac_flags;
 	u32 sbands_flags = 0;
@@ -1980,9 +1982,7 @@
 	nvm->valid_tx_ant = (u8)le32_to_cpu(rsp->phy_sku.tx_chains);
 	nvm->valid_rx_ant = (u8)le32_to_cpu(rsp->phy_sku.rx_chains);
 
-	if (le32_to_cpu(rsp->regulatory.lar_enabled) &&
-	    fw_has_capa(&fw->ucode_capa,
-			IWL_UCODE_TLV_CAPA_LAR_SUPPORT)) {
+	if (le32_to_cpu(rsp->regulatory.lar_enabled) && lar_fw_supported) {
 		nvm->lar_enabled = true;
 		sbands_flags |= IWL_NVM_SBANDS_FLAGS_LAR;
 	}
diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h
--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h	2023-08-10 16:47:12.435970941 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h	2023-08-10 17:12:24.565417931 -0500
@@ -22,7 +22,7 @@
 };
 
 /**
- * iwl_parse_nvm_data - parse NVM data and return values
+ * const struct iwl_fw *fw,iwl_parse_nvm_data - parse NVM data and return values
  *
  * This function parses all NVM values we need and then
  * returns a (b/drivers/net/wireless/intel/iwlwifily allocated) struct containing all the
@@ -35,7 +35,7 @@
 		   const __be16 *nvm_hw, const __le16 *nvm_sw,
 		   const __le16 *nvm_calib, const __le16 *regulatory,
 		   const __le16 *mac_override, const __le16 *phy_sku,
-		   u8 tx_chains, u8 rx_chains);
+		   u8 tx_chains, u8 rx_chains, bool lar_fw_supported);
 
 /**
  * iwl_parse_mcc_info - parse MCC (mobile country code) info coming from FW
diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h	2023-08-10 16:47:44.056340065 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h	2023-08-10 17:12:06.957214373 -0500
@@ -1355,6 +1355,8 @@
 	bool tlv_lar = fw_has_capa(&mvm->fw->ucode_capa,
 				   IWL_UCODE_TLV_CAPA_LAR_SUPPORT);
 
+	if (iwlwifi_mod_params.lar_disable)
+		return false;
 	/*
 	 * Enable LAR only if it is supported by the FW (TLV) &&
 	 * enabled in the NVM
diff --color -ruN a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c
--- a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c	2023-08-10 16:48:01.724546306 -0500
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c	2023-08-10 17:11:19.380664536 -0500
@@ -220,6 +220,7 @@
 	struct iwl_nvm_section *sections = mvm->nvm_sections;
 	const __be16 *hw;
 	const __le16 *sw, *calib, *regulatory, *mac_override, *phy_sku;
+	bool lar_enabled;
 	int regulatory_type;
 
 	/* Checking for required sections */
@@ -270,9 +271,14 @@
 		(const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY_SDP].data :
 		(const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY].data;
 
+	lar_enabled = !iwlwifi_mod_params.lar_disable &&
+		fw_has_capa(&mvm->fw->ucode_capa,
+			IWL_UCODE_TLV_CAPA_LAR_SUPPORT);
+
 	return iwl_parse_nvm_data(mvm->trans, mvm->cfg, mvm->fw, hw, sw, calib,
 				  regulatory, mac_override, phy_sku,
-				  mvm->fw->valid_tx_ant, mvm->fw->valid_rx_ant);
+				  mvm->fw->valid_tx_ant, mvm->fw->valid_rx_ant,
+				  lar_enabled);
 }
 
 /* Loads the NVM data stored in mvm->nvm_sections into the NIC */
